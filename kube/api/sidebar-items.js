initSidebarItems({"enum":[["PatchStrategy","For patch different patch types are supported. See https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/#use-a-json-merge-patch-to-update-a-deployment Apply strategy is kinda special"],["PropagationPolicy","Propagation policy when deleting single objects"],["WatchEvent","A raw event returned from a watch query"]],"struct":[["Api","A typed Api variant that does not expose request internals"],["DeleteParams","Common query parameters for delete calls"],["Informer","An event informer for a `Resource`"],["Initializers","Initializers tracks the progress of initialization"],["ListParams","Common query parameters used in watch/list/delete calls on collections"],["LogParams",""],["Object","A standard kubernetes object with .spec and .status"],["ObjectList","A generic kubernetes object list"],["ObjectMeta","Metadata that all persisted resources must have"],["PatchParams","Common query parameters for patch calls"],["PostParams","Common query parameters for put/post calls"],["RawApi","RawRawApi generation data"],["Reflector","A reflection of `Resource` state in kubernetes"],["ScaleSpec","Scale spec from api::autoscaling::v1"],["ScaleStatus","Scale status from api::autoscaling::v1"],["TypeMeta",""],["Void","Empty struct for when no Spec is required"]],"trait":[["KubeObject","Accessor trait needed to build higher level abstractions on kubernetes objects"],["Log",""]],"type":[["Cache","Cache resource map exposed by the Reflector"],["Scale",""]]});